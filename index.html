<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touran Khan</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
            line-height: 1.6;
            color: #333;
            position: relative;
            min-height: 100vh;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3rem;
        }

        .name {
            font-size: 1.2rem;
            color: #d35400;
            text-decoration: none;
        }

        nav a {
            margin-left: 1.5rem;
            text-decoration: none;
            color: #333;
        }

        nav a:hover {
            text-decoration: underline;
        }

        main {
            font-size: 1.1rem;
        }

        a {
            color: #8b4513;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        p {
            margin-bottom: 1.5rem;
        }

        #automataCanvas {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            opacity: 0.9;
            width: 200px;
            height: 200px;
        }
    </style>
</head>
<body>
    <header>
        <a href="/" class="name">Touran Khan</a>
        <nav>
            <a href="/bookshelf">Bookshelf</a>
            <a href="/writing">Writing</a>
            <a href="/contact">Contact</a>
        </nav>
    </header>

    <main>
        <p>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor 
            incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud 
            exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute 
            irure dolor in <a href="#">reprehenderit</a> in voluptate velit esse cillum dolore 
            eu fugiat nulla pariatur.
        </p>

        <p>
            Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium 
            doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore 
            veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam 
            voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur 
            magni dolores eos qui ratione voluptatem sequi nesciunt.
        </p>

        <p>
            At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis 
            praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias 
            excepturi sint occaecati cupiditate non provident. You can find me on Twitter at 
            <a href="#">@tourankhan</a>. Similique sunt in culpa qui officia deserunt mollitia 
            animi, id est laborum et dolorum fuga.
        </p>
    </main>

    <canvas id="automataCanvas" width="200" height="200"></canvas>

    <script>
        const canvas = document.getElementById('automataCanvas');
        const ctx = canvas.getContext('2d');
        
        const hexSize = 8; // Reduced size to fit smaller canvas
        const hexHeight = hexSize * 2;
        const hexWidth = Math.sqrt(3) * hexSize;
        const cols = Math.floor(canvas.width / hexWidth) - 1;
        const rows = Math.floor(canvas.height / (hexHeight * 0.75)) - 1;

        const COLORS = ['red', 'yellow', 'blue'];
        let grid = Array(rows).fill().map(() => Array(cols).fill(null));

        // [Previous helper functions remain exactly the same]
        function getNextColor(currentColor) {
            if (Math.random() < 0.15) {
                return COLORS[Math.floor(Math.random() * COLORS.length)];
            }
            if (!currentColor) return COLORS[Math.floor(Math.random() * COLORS.length)];
            const currentIndex = COLORS.indexOf(currentColor);
            return COLORS[(currentIndex + 1) % COLORS.length];
        }

        function drawHexagon(x, y, size, color) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3;
                const xPos = x + size * Math.cos(angle);
                const yPos = y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(xPos, yPos);
                else ctx.lineTo(xPos, yPos);
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        function countNeighbors(row, col) {
            const isEvenRow = row % 2 === 0;
            const directions = isEvenRow ? [
                [-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]
            ] : [
                [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]
            ];
            
            let count = 0;
            let colors = { red: 0, yellow: 0, blue: 0 };
            
            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    const neighborColor = grid[newRow][newCol];
                    if (neighborColor) {
                        count++;
                        colors[neighborColor]++;
                    }
                }
            }
            return { count, colors };
        }

        function createSeedPattern(centerRow, centerCol) {
            if (centerRow >= 0 && centerRow < rows - 1 && centerCol >= 0 && centerCol < cols - 1) {
                grid[centerRow][centerCol] = COLORS[Math.floor(Math.random() * COLORS.length)];
                if (Math.random() < 0.8) {
                    grid[centerRow + 1][centerCol] = COLORS[Math.floor(Math.random() * COLORS.length)];
                }
                if (Math.random() < 0.5) {
                    grid[centerRow][centerCol + 1] = COLORS[Math.floor(Math.random() * COLORS.length)];
                }
            }
        }

        function initializeGrid() {
            grid = Array(rows).fill().map(() => Array(cols).fill(null));
            
            for (let i = 0; i < 3; i++) {
                const centerRow = Math.floor(Math.random() * (rows - 4)) + 2;
                const centerCol = Math.floor(Math.random() * (cols - 4)) + 2;
                createSeedPattern(centerRow, centerCol);
            }
        }

        function updateGrid() {
            const newGrid = Array(rows).fill().map(() => Array(cols).fill(null));
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const { count, colors } = countNeighbors(row, col);
                    const currentState = grid[row][col];
                    
                    if (currentState) {
                        if (count === 3 || count === 4 || 
                            (Math.random() < 0.3 && count === 2) ||
                            (Math.random() < 0.15 && count === 1)) {
                            newGrid[row][col] = getNextColor(currentState);
                        }
                    } else {
                        if (count === 2 || (Math.random() < 0.1 && count === 3)) {
                            const dominantColor = Object.entries(colors)
                                .reduce((a, b) => b[1] > a[1] ? b : a, ['red', 0])[0];
                            newGrid[row][col] = getNextColor(dominantColor);
                        }
                    }

                    if (!newGrid[row][col] && count > 0 && Math.random() < 0.005) {
                        newGrid[row][col] = COLORS[Math.floor(Math.random() * COLORS.length)];
                    }
                }
            }
            
            grid = newGrid;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (grid[row][col]) {
                        const x = col * hexWidth + (row % 2) * (hexWidth / 2) + hexSize;
                        const y = row * (hexHeight * 0.75) + hexSize;
                        drawHexagon(x, y, hexSize, grid[row][col]);
                    }
                }
            }
        }

        let frameCount = 0;
        function animate() {
            if (frameCount % 10 === 0) {
                updateGrid();
            }
            draw();
            frameCount++;
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', initializeGrid);
        initializeGrid();
        animate();
    </script>
</body>
</html>
